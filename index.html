<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>Microservices</title>

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/night.css">

    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="lib/css/zenburn.css">

    <!-- Custom styles -->
    <link rel="stylesheet" href="css/presentation.css">

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>
  </head>
  <body>
    <div class="reveal">
      <div class="slides">

        <section id="welcome">
          <h1>Microservices</h1>

          <h3>A high level introduction</h3>

          <div id="author">John Freeman</div>
          <div id="company">GantSign Ltd.</div>
          <div id="date">21 Nov 2016</div>

          <div id="license">
            <a rel="license" href="http://creativecommons.org/licenses/by/4.0/"><img alt="Creative Commons Licence" style="border-width:0" data-src="https://i.creativecommons.org/l/by/4.0/88x31.png" /></a><br />
            This work is licensed under a
            <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>.
          </div>

          <aside class="notes">
            <p>Welcome</p>
            <p>
              There are aany presentations covering the low level details of
              implementing microservices: e.g. Docker, Spring-Boot, Vert.x &amp;
              Akka
            </p>
            <p>
              This presentation is going to step back, look at the benefits,
              risks, patterns and organizational impacts of microservices
            </p>
          </aside>
        </section>

        <section>
          <section data-background-color="#FF7600">
            <h1>What are microservices</h1>

            <aside class="notes">
              <p>
                No standard definition but I'm going to put forward some common
                features of a microservice.
              </p>
            </aside>
          </section>

          <section data-background-color="#FF7600">
            <h1>Narrow purpose</h1>

            <aside class="notes">
              <p>
                Microservers are a way of splitting up an application into smaller
                applications dealing with specific areas of functionality.
              </p>
            </aside>
          </section>

          <section data-background-color="#FF7600">
            <h1>Part of a larger system</h1>

            <aside class="notes">
              <p>
                If you just have a small application you can call it a microservice
                but the typical issues won't apply.
              </p>
            </aside>
          </section>

          <section data-background-color="#FF7600">
            <h1>Implementation isolation</h1>

            <aside class="notes">
              <p>
                The implementation of each microservice is hidden from the others
                behind a clearly defined external API.
              </p>
            </aside>
          </section>

          <section data-background-color="#FF7600">
            <h1>Parallel teams</h1>

            <aside class="notes">
              <p>
                A microservice project consists of multiple teams working in
                parallel.
              </p>
              <p>
                Microservices should be developed independently, with the
                external API being the interface between teams.
              </p>
            </aside>
          </section>

          <section data-background-color="#FF7600">
            <h1>Opinionated SOA</h1>

            <aside class="notes">
              <p>
                Microservices are an opinionated form of Service Oriented
                Architecture.
              </p>
              <p>
                Commonly this includes:
                <ul>
                  <li>Dropping the enterprise container</li>
                  <li>Hosting each service separately</li>
                  <li>Leveraging cloud infrastructure</li>
                </ul>
              </p>
            </aside>
          </section>

          <section data-background-color="#FF7600">
            <img data-src="img/soa-vs-ms.png">

            <aside class="notes">
              <p>
                This is a graph of Google searches for SOA and microservices
                since 2004.
              </p>
              <p>
                Popularity for SOA peeked in 2006, since then it's fallen by
                about 75%.
              </p>
              <p>
                If you were a developer in 2006, you probably remember every
                company wanted to be able to say their product was built using
                SOA; this is beginning to happen with microservices today.
              </p>
              <p>
                I suspect what this graph shows is for about three quarters of
                companies who tried SOA, the additional effort didn't provide
                sufficient benefit, and they mostly abandoned it.
              </p>
              <p>
                Since microsevices are a form of SOA let's assume the same is
                true and about 25% of companies trying microservices will
                benefit.
              </p>
              <p>
                This presentation will help you to identify if your project is
                likely to benefit, and to put you on the right path to achieving
                those benefits.
              </p>
            </aside>
          </section>
        </section>

        <section class="bad-dark">
          <h2>Large monolithic applications</h2>

          <ul>
            <li><strong>Difficult to scale team</strong></li>
            <li><strong>Hard to keep pace with technology</strong></li>
            <li>Slow to build, deploy and run</li>
            <li>Long release cycles</li>
            <li>Large risky releases</li>
            <li>Long on-boarding time for developers</li>
          </ul>

          <aside class="notes">
            <p>
              Lets start by identifying some of the issues with large monolithic
              applications.
            </p>
          </aside>

        </section>

        <section class="benefits">
          <section data-background-color="#01939A">
            <h1>Benefits of microservices</h1>
          </section>

          <section data-background-color="#01939A">
            <h1>Parallel teams</h1>

            <aside class="notes">
              <p>
                The most compelling reason to use microservices is you can achieve
                much greater total productivity on a large project.
              </p>
              <p>
                Multiple small teams can work on separate microservices without
                conflicting with each other or waiting for each other.
              </p>
              <p>
                Productivity scales almost linearly until you have the
                same number of teams as microservices in development.
              </p>
              <p>
                This allows for significantly shorter delivery timescales on large projects.
              </p>
            </aside>
          </section>

          <section data-background-color="#01939A">
            <h1>Cloud friendly</h1>

            <aside class="notes">
              <ul>
                <li>Fine grained salability</li>
                <li>Use cheaper VMs with lower resource requirements</li>
                <li>Lock free</li>
              </ul>
            </aside>
          </section>

          <section data-background-color="#01939A">
            <h1>Implementation diversity</h1>

            <aside class="notes">
              <ul>
                <li>Use the right tool for each job</li>
                <li>Keep pace with advancements</li>
                <li>Greater recruitment pool</li>
              </ul>
            </aside>
          </section>

          <section data-background-color="#01939A">
            <h1>
              New service<br/>
              = clean start
            </h1>

            <aside class="notes">
              <p>
                New services are always an opportunity to update to the latest
                advances in technology.
              </p>
              <p>Refine your implementation of the design patterns</p>
              <p>Iterative improvement</p>
            </aside>
          </section>

          <section data-background-color="#01939A">
            <h1>Manageable size</h1>

            <aside class="notes">
              <p>Each microservice is a manageable size.</p>
              <p>
                Less to:
                <ul>
                  <li>learn</li>
                  <li>update</li>
                  <li>rewrite</li>
                  <li>build</li>
                  <li>deploy</li>
                  <li>run</li>
                </ul>
              </p>
              <p>They're never be too big to refactor.</p>
            </aside>
          </section>

          <section data-background-color="#01939A">
            <h1>Focus on services that change</h1>

            <aside class="notes">
              <p>
                Even if only 10% of the microservices are using the latest
                technology and best practice, if these are the 10% that are
                under active development, you'll still have a happy development
                team.
              </p>
              <p>
                If a service is working and not under development there is no
                need to spend money updating it.
              </p>
              <p>Still need to apply security patches/updates.</p>
            </aside>
          </section>

          <section data-background-color="#01939A">
            <h1>Frequent, small, low risk releases</h1>

            <aside class="notes">
              <p>
                You can do canary releases during office hours rather than 2 am
                on a Sunday morning.
              </p>
            </aside>
          </section>
        </section>

        <section class="bad-dark">
          <section>
            <h1>Misconceptions about microservices</h1>
          </section>

          <section>
            <h1>Small = simpler</h1>
          </section>

          <section>
            <h1>Small = less effort</h1>

            <aside class="notes">
              <p>
                This is not the case because:
                <ul>
                  <li>Local method calls become remote procedure calls</li>
                  <li>ACID database transaction become distributed transactions
                      with eventual consistency</li>
                  <li>Code and data has to be duplicated between services</li>
                  <li>You spend more time releasing and versioning artifacts</li>
                </ul>
              </p>
            </aside>
          </section>

          <section>
            <h1>It's another evolutionary change</h1>

            <aside class="notes">
              <p>It's not a simple drop in implementation change like choosing
                 between Java EE and the Spring Framework.</p>
              <p>
                It's going to affect everything you do:
                <ul>
                  <li>Some staff roles will be created</li>
                  <li>Some staff roles will be eliminated</li>
                  <li>Responsibilities of remaining staff will change</li>
                  <li>Your organizational structure will need to change</li>
                  <li>It will change the way you run projects</li>
                  <li>Your APIs will be different</li>
                  <li>You'll be using different design patterns</li>
                  <li>You'll be using different databases</li>
                  <li>It'll change the way you test software</li>
                  <li>It'll change the way you support software</li>
                  <li>It'll change the way you release software</li>
                </ul>
              </p>
            </aside>
          </section>
        </section>

        <section class="bad-light">
          <section data-background-color="#FFAD00">
            <h1>What makes microservices hard to write</h1>
          </section>

          <section data-background-color="#FFAD00">
            <h1>Distributed transactions</h1>

            <aside class="notes">
              Even if your service doesn't use distributed transactions
              it will likely still be part of one.
            </aside>
          </section>

          <section data-background-color="#FFAD00">
            <h1>Eventual consistency</h1>

            <aside class="notes">
              Many cloud services, particularly NoSQL databases, require eventual consistency
              to be able to work at scale.
            </aside>
          </section>

          <section data-background-color="#FFAD00">
            <h2>Distributed transactions</h2>

            <ul class="increased-spacing">
              <li>Much harder to implement than local transactions</li>
              <li>Requires more code</li>
              <li>Increased latency</li>
              <li>
                Approaches:
                <ul>
                  <li>Compensating transaction / Saga pattern</li>
                  <li>2 phase commit (requires synchronous implementation)</li>
                </ul>
              </li>
              <li>Still may not be able to fully commit/rollback</li>
              <li>Easy to make happy path work but fail to handle errors
                  correctly</li>
            </ul>
          </section>

          <section data-background-color="#FFAD00">
            <h2>Distributed transactions (cont.)</h2>

            <ul>
              <li>
                Advice:
                <ul>
                  <li>Don't ignore it</li>
                  <li>Document your service behavior</li>
                  <li>Avoid when unnecessary</li>
                  <li>Consider using transactional message queue</li>
                  <li>Read SOA documentation on the topic</li>
                </ul>
              </li>
            </ul>
          </section>

          <section data-background-color="#FFAD00">
            <h2>Eventual consistency</h2>

            <ul class="increased-spacing">
              <li>Much harder to work with than ACID behaviour</li>
              <li>Not immediately readable</li>
              <li>Not repeatedly readable</li>
              <li>
                Advice:
                <ul>
                  <li>Use event sourcing and CQRS</li>
                  <li>Pass your domain objects between services rather than
                      re-querying them</li>
                  <li>Avoid UI/APIs requiring immediate consistency</li>
                  <li>Implement auto-retry where necessary</li>
                </ul>
              </li>
            </ul>
          </section>
        </section>

        <section class="mixed-dark">
          <section>
            <h2>API considerations</h2>

            <ul class="increased-spacing">
              <li>Idempotentcy</li>
              <li>UUIDs</li>
              <li>Event sourcing</li>
              <li>Reactive systems</li>
              <li>Distributed transactions</li>
              <li>Eventual consistency</li>
            </ul>

            <aside class="notes">
              <ul>
                <li>Idempotentcy: you need to make it safe to retry API calls
                    because there are many more potential points of failure.</li>
                <li>UUIDs: help you to implement idempotentcy; NoSQL databases
                    generally don't provide sequential ID generators.</li>
                <li>Event Sourcing: helps with eventually consistent databases</li>
                <li>Reactive Systems: helps with performance and reliability</li>
                <li>Distributed transactions: an unavoidable side effect of
                    using microservices</li>
                <li>Eventual consistency: used to improve scalability</li>
              </ul>
            </aside>

          </section>

          <section>
            <h2>UUIDs</h2>

            <ul class="increased-spacing">
              <li>Can't definitively check that a UUID hasn't been used
                  (eventual consistency)</li>
              <li>Accidental collisions are astronomically unlikely</li>
              <li>
                Protect against a client maliciously overwriting records
                <ul>
                  <li>e.g. Use hierarchy of IDs so client can only modify their
                      own records</li>
                  <li>
                    e.g. UUIDs have to be requested from the server
                    <ul>
                      <li>Use secure hash to protect from client modification
                          (slow)</li>
                    </ul>
                  </li>
                </ul>
              </li>
            </ul>
          </section>

          <section>
            <h2>Event sourcing</h2>

            <ul class="increased-spacing">
              <li>No "SELECT FOR UPDATE" with an eventually consistent database</li>
              <li>Risk of overwriting concurrent changes</li>
              <li>Send &amp; store the events (changes) instead of whole entities</li>
              <li>Update API has to be based on events (changes)</li>
              <li>Reconstruct the state of the entity at query time</li>
              <li>Query API for reconstructed entities (CQRS)</li>
              <li>Complete history</li>
              <li>Audit log</li>
            </ul>
          </section>

          <section>
            <h2>Event sourcing (contd.)</h2>

            <ul class="increased-spacing">
              <li>
                Problems:
                <ul>
                  <li>
                    What order do you apply the changes?
                    <ul>
                      <li>Business rules e.g. based on a state model</li>
                      <li>Timestamp</li>
                    </ul>
                  </li>
                  <li>Handling schema changes</li>
                  <li>The more events the slower it is to query</li>
                  <li>More difficult to query entities by mutable properties</li>
                </ul>
              </li>
              <li>
                Advice:
                <ul>
                  <li>Only use it for mutable entities</li>
                  <li>Use immutable entities where possible</li>
                  <li>Give nested entities UUIDs (especially if contained in
                      arrays)</li>
                </ul>
              </li>
            </ul>
          </section>

          <section>
            <h2>Reactive systems</h2>

            <ul class="increased-spacing">
              <li>Message driven</li>
              <li>
                Asynchronous API
                <ul>
                  <li>Don't return success/failure status</li>
                  <li>Don't return data</li>
                  <li>Don't do RPC over message queue</li>
                </ul>
              </li>
              <li>Good fit with distributed transactions</li>
              <li>You need to implement backpressure</li>
              <li>Often less convent/practical for the client</li>
            </ul>
          </section>

          <section>
            <h2>Reactive systems (cont.)</h2>

            <h3>Non-reactive example</h3>

            <img data-src="img/rpc.svg" class="flow-diagram">
          </section>

          <section>
            <h2>Reactive systems (cont.)</h2>

            <h3>Reactive example</h3>

            <img data-src="img/reactive-happy.svg" class="flow-diagram">

            <aside class="notes">
              <ul>
                <li>No 1:1 RPC queues</li>
                <li>Passes data to avoid eventual consistency issues</li>
                <li>Validate and update the message data</li>
                <li>Resilient to node failure</li>
                <li>Linear flow easy to rollback</li>
              </ul>
            </aside>

          </section>

          <section>
            <h2>Reactive systems (cont.)</h2>

            <h3>State transitions</h3>

            <img data-src="img/reactive-state.svg" class="flow-diagram">
          </section>

          <section>
            <h2>Reactive systems (cont.)</h2>

            <h3>Failure handling</h3>

            <img data-src="img/reactive-unhappy1.svg" class="flow-diagram">
          </section>

          <section>
            <h2>Reactive systems (cont.)</h2>

            <h3>Rollback</h3>

            <img data-src="img/reactive-unhappy2.svg" class="flow-diagram">
          </section>
        </section>

        <section>
          <section data-background-color="#FF7600">
            <h1>Infrastructure requirements</h1>

            <aside class="notes">
              <p>
                More infrastructure requirements than a typical monolithic
                application
              </p>
            </aside>
          </section>

          <section data-background-color="#FF7600">
            <h1>Cloud platform</h1>

            <aside class="notes">
              <ul>
                <li>Too many servers to maintain manually</li>
                <li>Dev, test, UAT, live</li>
                <li>
                  Advice:
                  <ul>
                    <li>Consider off the shelf services from your provider</li>
                    <li>If unsure choose Amazon (easy to find people with experience)</li>
                  </ul>
                </li>
              </ul>
            </aside>
          </section>

          <section data-background-color="#FF7600">
            <h1>Container manager</h1>

            <aside class="notes">
              <ul>
                  <li>Too many containers instances to manage manually</li>
                  <li>e.g. Docker Swarm / Kubernetes</li>
              </ul>
            </aside>
          </section>

          <section data-background-color="#FF7600">
            <h1>Identity and access management (IAM) service</h1>

            <aside class="notes">
              <ul>
                <li>User, passwords and access key management</li>
                <li>Configure who has access to what</li>
              </ul>
            </aside>
          </section>

          <section data-background-color="#FF7600">
            <h1>API gateway service</h1>

            <aside class="notes">
              <ul>
                <li>External entry point to your application</li>
                <li>Permit/deny access based on IAM Service</li>
                <li>Routes external APIs to internal microservices</li>
              </ul>
            </aside>
          </section>

          <section data-background-color="#FF7600">
            <h1>Monitoring and log analytics service</h1>

            <aside class="notes">
              <ul>
                <li>Auto scaling</li>
                <li>Backpressure</li>
                <li>Alerting</li>
                <li>Resolve partial transactions</li>
                <li>Status dashboards</li>
                <li>Performance analytics</li>
                <li>Support queries</li>
                <li>Too many separate log files to look at individually</li>
              </ul>
            </aside>
          </section>

          <section data-background-color="#FF7600">
            <h1>Configuration service</h1>

            <aside class="notes">
              <ul>
                <li>Configuration is dynamic</li>
                <li>Nodes added/removed</li>
                <li>Central location to manage/lookup configuration</li>
              </ul>
            </aside>
          </section>

          <section data-background-color="#FF7600">
            <h1>Notification service</h1>

            <aside class="notes">
              <ul>
                <li>Email</li>
                <li>Mobile push</li>
                <li>HTTP Push</li>
              </ul>
            </aside>
          </section>

          <section data-background-color="#FF7600">
            <h1>Deployment service</h1>

            <aside class="notes">
              <ul>
                <li>Setup complete DevOps pipeline</li>
                <li>Synchronization/freezes for large releases not practical</li>
                <li>Small releases would be too frequent to do manually</li>
                <li>Track release dependencies</li>
                <li>Need excellent automated test coverage</li>
                <li>Consider feature flags</li>
              </ul>
            </aside>
          </section>
        </section>

        <section class="bad-dark">
          <section>
            <h1>Difficult organizational changes</h1>
          </section>

          <section>
            <h2>The easiest way to sabotage a microservice project, is to undermine the ability of your teams to work in parallel.</h2>

            <aside class="notes">
              <ul>
                <li>Teams should work in parallel rather than concurrently</li>
                <li>Concurrently is where the teams have to coordinate their work because it is affecting the other teams</li>
                <li>Parallel is where the work is separate and doesn't require coordination</li>
                <li>Coordinating work between teams slows everyone down and causes havoc with planning</li>
              </ul>
            </aside>
          </section>

          <section>
            <h2>Do not share code between microservices</h2>

            <ul class="increased-spacing">
              <li>Changes are not atomic with multiple repositories</li>
              <li>Takes multiple teams to schedule and apply changes</li>
              <li>The more microservices that share the code the more to update</li>
              <li>Technical debt builds up on services that aren't kept up to date</li>
              <li>Can impact the release schedule across multiple teams</li>
              <li>May take a long time to get feedback and iterate improvements</li>
            </ul>
          </section>

          <section>
            <h2>Do not share code between microservices (cont.)</h2>

            <ul class="increased-spacing">
              <li>
                If you do share code:
                <ul>
                  <li>Keep each library small with a narrow purpose</li>
                  <li>Do not share code until you are sure it is stable</li>
                </ul>
              </li>
              <li>
                This rule doesn't apply to third party libraries and frameworks as:
                <ul>
                  <li>There is no need to synchronize these between microservices</li>
                  <li>There is less chance of backwards incompatible changes</li>
                </ul>
              </li>
            </ul>
          </section>

          <section>
            <h2>Do not mandate specific frameworks, libraries, languages and internal implementation patterns</h2>

            <aside class="notes">
              You can still impose requirement on services for logging and monitoring etc.
            </aside>
          </section>

          <section>
            <h2>Do not maintain a central design authority with approval over all design decisions</h2>
          </section>

          <section>
            <h2>Do not run a microservice project like a large monolithic enterprise application project</h2>
          </section>
        </section>

        <section>
          <section data-background-color="#01939A">
            <h1>Running a microservice project</h1>

            <aside class="notes">
            </aside>
          </section>

          <section data-background-color="#01939A">
            <h1>Embrace diversity</h1>

            <aside class="notes">
              <p>You'll likely end up with a mix of teams e.g.:</p>
              <ul>
                <li>multiple Java teams because developers resources are easily available</li>
                <li>a Scala team that work on the most performance critical services</li>
                <li>a Node.JS team for services specific to web frontends</li>
                <li>a Go team for simple services where lower resource requirements
                can deliver significant savings on hosting costs</li>
              </ul>
            </aside>
          </section>

          <section data-background-color="#01939A">
            <h1>Communicate ideas and best practice</h1>

            <aside class="notes">
              Encourages a level of consistency between teams without holding anyone up.
            </aside>
          </section>

          <section data-background-color="#01939A">
            <h1>Have an API guild</h1>

            <aside class="notes">
              <ul>
                <li>Ensures the APIs are consistent</li>
                <li>Important to get the API right the first time</li>
              </ul>
            </aside>
          </section>

          <section data-background-color="#01939A">
            <h1>Strictly follow TDD/BDD</h1>
          </section>

          <section data-background-color="#01939A">
            <h2>Run each team as if they are a separate company</h2>

            <ul class="increased-spacing">
              <li>Make teams responsible for design, implementation and
                  <b>support</b></li>
              <li>Track metrics for each team</li>
              <li>Bill internal users for using microservices</li>
              <li>Empower teams with the agility of a start up</li>
            </ul>
          </section>
        </section>

        <section class="mixed-light">
          <section data-background-color="#FF7600">
            <h2>Replacing an existing application</h2>

            <ul class="increased-spacing">
              <li>
                Need to be able to change the APIs
                <ul>
                  <li>UUIDs, idempotent, distributed transactions, asynchronous,
                      and event sourcing</li>
                </ul>
              </li>
              <li>
                Beware of:
                <ul>
                  <li>Distributed transactions</li>
                  <li>Eventual consistency</li>
                  <li>Increased latency</li>
                  <li>Low test coverage</li>
                </ul>
              </li>
            </ul>
          </section>

          <section data-background-color="#FF7600">
            <h2>Replacing an existing application (cont.)</h2>

            <ul class="increased-spacing">
              <li>Relatively long term investment</li>
              <li>
                Advice:
                <ul>
                  <li>
                    Keep refactoring of existing code/database to a minimum
                    <ul>
                      <li>UUIDs are 128 bit so won't fit in a Java long</li>
                      <li>It's normal to duplicate data</li>
                    </ul>
                  </li>
                  <li>Easier to migrate whole functional areas at a time</li>
                  <li>Consider total rewrite rather than gradual migration</li>
                </ul>
              </li>
            </ul>
          </section>
        </section>

        <section data-background-color="#01939A">
          <h2>When to use microservices</h2>

          <ul>
            <li>
              If you need to write a large application quickly
              <ul>
                <li>(as long as you can resource multiple teams)</li>
              </ul>
            </li>
            <li>If you're maintaining a large application for a long time</li>
            <li>If you need fine grained scalability</li>
          </ul>
        </section>

        <section class="bad-dark">
          <h2>When not to use microservices</h2>

          <ul class="increased-spacing">
            <li>If you're a small start up with tight resources</li>
            <li>If the application is small and unlikely to grow</li>
            <li>If you primarily need ACID behavior</li>
            <li>If you have a lot of cross service transactions</li>
          </ul>
        </section>

        <section data-background-color="#FF7600" class="mixed-light">
          <h2>In conclusion</h2>

          <ul class="increased-spacing">
            <li>Revolutionary change in approach</li>
            <li>More effort to write but scales better</li>
            <li>Large increase in skill set requirements</li>
            <li>Don't underestimate the task</li>
            <li>Bad idea for most small projects</li>
            <li>Worth considering for most large projects</li>
          </ul>
        </section>
      </div>
    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.js"></script>

    <script>
      // More info https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        history: true,

        // More info https://github.com/hakimel/reveal.js#dependencies
        dependencies: [
          { src: 'plugin/markdown/marked.js' },
          { src: 'plugin/markdown/markdown.js' },
          { src: 'plugin/notes/notes.js', async: true },
          { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
        ]
      });
    </script>
  </body>
</html>
