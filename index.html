<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>Microservices</title>

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/night.css">

    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="lib/css/zenburn.css">

    <!-- Custom styles -->
    <link rel="stylesheet" href="css/presentation.css">

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>
  </head>
  <body>
    <div class="reveal">
      <div class="slides">

        <section id="welcome">
          <h1>Microservices</h1>

          <h3>A high level introduction</h3>

          <div id="author">John Freeman</div>
          <div id="company">GantSign Ltd.</div>
          <div id="date">7 Jan 2017</div>

          <div id="license">
            <a rel="license" href="http://creativecommons.org/licenses/by/4.0/"><img alt="Creative Commons Licence" style="border-width:0" data-src="https://i.creativecommons.org/l/by/4.0/88x31.png" /></a><br />
            This work is licensed under a
            <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>.
          </div>

          <aside class="notes">
            <p>Welcome</p>
            <p>
              There are many presentations covering the low level details of
              implementing microservices: e.g. Docker, Spring-Boot, Vert.x &amp;
              Akka.
            </p>
            <p>
              This presentation is going to step back to look at the challenges,
              benefits and organizational impacts of adopting microservices.
            </p>
            <p>
              This presentation is aimed at both technical and non-technical
              team members.
            </p>
            <p>
              I will be introducing some of the technical concepts involved,
              but I'm not going to dive into the low level technical details.
            </p>
          </aside>
        </section>

        <section>
          <section data-background-color="#FF7600">
            <h1>What are microservices?</h1>

            <aside class="notes">
              <p>
                No standard definition but there are some common features of
                microservices.
              </p>
            </aside>
          </section>

          <section data-background-color="#FF7600">
            <h1>Narrow purpose</h1>

            <aside class="notes">
              <p>
                Microservers are a way of splitting up an application into smaller
                applications dealing with specific areas of functionality.
              </p>
            </aside>
          </section>

          <section data-background-color="#FF7600">
            <h1>Part of a larger system</h1>

            <aside class="notes">
              <p>
                If you just have a small application you can call it a microservice
                but the typical issues won't apply.
              </p>
            </aside>
          </section>

          <section data-background-color="#FF7600">
            <h1>Implementation isolation</h1>

            <aside class="notes">
              <p>
                The implementation of each microservice is hidden from the
                others behind a clearly defined external API.
              </p>
              <p>
                This means separate source repositories, separate builds,
                separate databases, independent versioning and independent
                releases.
              </p>
            </aside>
          </section>

          <section data-background-color="#FF7600">
            <h1>Parallel teams</h1>

            <aside class="notes">
              <p>
                A microservice project consists of multiple teams working in
                parallel.
              </p>
              <p>
                Microservices should be developed independently, with the
                external API being the interface between teams.
              </p>
            </aside>
          </section>

          <section data-background-color="#FF7600">
            <h1>Opinionated SOA</h1>

            <aside class="notes">
              <p>
                Microservices are an opinionated form of Service Oriented
                Architecture.
              </p>
              <p>
                Distinguishing features typically include:
                <ul>
                  <li>Hosting each service separately</li>
                  <li>Dropping the enterprise container</li>
                  <li>Leveraging cloud infrastructure</li>
                </ul>
              </p>
            </aside>
          </section>

          <section data-background-color="#FF7600">
            <img data-src="img/soa-vs-ms.png">

            <aside class="notes">
              <p>
                This is a graph of Google searches for SOA and microservices
                since 2004.
              </p>
              <p>
                Popularity for SOA peeked in 2006, since then it's fallen by
                about 75%.
              </p>
              <p>
                If you were a developer in 2006, you probably remember every
                company wanted to be able to say their product was built using
                SOA; the same thing is beginning to happen with microservices
                today.
              </p>
              <p>
                I suspect what this graph shows is for about three quarters of
                companies who tried SOA, the additional effort didn't provide
                sufficient benefit, and they mostly abandoned it.
              </p>
              <p>
                Since microsevices are a form of SOA let's assume the same is
                true and about 25% of companies trying microservices will
                benefit.
              </p>
              <p>
                This presentation will help you to identify if your project is
                likely to benefit, and to put you on the right path to achieving
                those benefits.
              </p>
            </aside>
          </section>
        </section>

        <section class="bad-dark">
          <h2>Large monolithic applications</h2>

          <ul>
            <li><strong>Difficult to scale team</strong></li>
            <li><strong>Hard to keep pace with technology</strong></li>
            <li>Slow to build, deploy and run</li>
            <li>Long release cycles</li>
            <li>Large risky releases</li>
            <li>Long on-boarding time for developers</li>
          </ul>

          <aside class="notes">
            <p>
              Lets start by identifying some of the issues with large monolithic
              applications.
            </p>
          </aside>

        </section>

        <section class="benefits">
          <section data-background-color="#01939A">
            <h1>Benefits of microservices</h1>
          </section>

          <section data-background-color="#01939A">
            <h1>Parallel teams</h1>

            <aside class="notes">
              <p>
                The most compelling reason to use microservices, is you can
                achieve much greater total productivity on a large project,
                by having parallel development teams.
              </p>
              <p>
                Multiple small teams can work on separate microservices without
                conflicting with each other or waiting for each other.
              </p>
              <p>
                Productivity scales almost linearly until you have the
                same number of teams as microservices in development.
              </p>
              <p>
                This allows for significantly shorter delivery timescales on large projects.
              </p>
            </aside>
          </section>

          <section data-background-color="#01939A">
            <h1>Cloud friendly</h1>

            <aside class="notes">
              <ul>
                <li>Fine grained salability</li>
                <li>Use cheaper VMs with lower resource requirements</li>
                <li>Use design patterns that avoid the need for locking between
                    nodes</li>
              </ul>
            </aside>
          </section>

          <section data-background-color="#01939A">
            <h1>Implementation diversity</h1>

            <aside class="notes">
              <ul>
                <li>Use the right tools for each job</li>
                <li>Keep pace with technology and best practice</li>
                <li>Access to a larger pool of developers to recruit from</li>
              </ul>
            </aside>
          </section>

          <section data-background-color="#01939A">
            <h1>
              New service<br/>
              = clean start
            </h1>

            <aside class="notes">
              <ul>
                <li>
                  New services are always an opportunity to update to the latest
                  advances in technology.
                </li>
                <li>
                  Refine your implementation of the design patterns
                </li>
                <li>
                  Iterative improvement
                </li>
              </ul>
            </aside>
          </section>

          <section data-background-color="#01939A">
            <h1>Manageable size</h1>

            <aside class="notes">
              <p>Each microservice is a manageable size.</p>
              <p>
                Less to:
                <ul>
                  <li>learn</li>
                  <li>update</li>
                  <li>rewrite</li>
                  <li>build</li>
                  <li>deploy</li>
                  <li>run</li>
                </ul>
              </p>
              <p>They're never be too big to refactor.</p>
            </aside>
          </section>

          <section data-background-color="#01939A">
            <h1>Focus on services that change</h1>

            <aside class="notes">
              <p>
                Even if only 10% of your microservices are using the latest
                technology and best practice, if these are the 10% that are
                under active development, you'll still have happy and well
                motivated developers.
              </p>
              <p>
                If a service is working and not under development there is no
                need to spend money updating it (other than applying security
                updates).
              </p>
            </aside>
          </section>

          <section data-background-color="#01939A">
            <h1>Frequent, small, low risk releases</h1>

            <aside class="notes">
              <p>
                You can even do canary releases during office hours with zero
                downtime.
              </p>
            </aside>
          </section>
        </section>

        <section class="bad-dark">
          <section>
            <h1>Misconceptions about microservices</h1>
          </section>

          <section>
            <h1>Small = simple</h1>
          </section>

          <section>
            <h2>Small	&ne; simple</h2>

            <div style="text-align: left">
              <p>
                Transactional properties
                <ul>
                  <li><span style="text-decoration: line-through">Atomicity</span> Distributed transactions</li>
                  <li><span style="text-decoration: line-through">Consistency</span> Eventual consistency</li>
                  <li><span style="text-decoration: line-through">Isolation</span> Event sourcing</li>
                  <li>Durability</li>
                </ul>
              </p>
              <p>
                Programming model for calling between services
                <ul>
                  <li><span style="text-decoration: line-through">Local synchronous method calls and exception handling</span><br/>
                      Reactive systems architecture</li>
                </ul>
              </p>
            </div>

            <aside class="notes">
              <p>
                If we look at the programming model we had with a large
                monolithic application, we typically had a relational database
                with ACID transactional properties and we called services using
                local method calls and exception handling.
              </p>
              <p>
                With microservices we replace this with distributed
                transactions, eventual consistency, event sourcing and reactive
                systems architecture.
              </p>
              <p>
                The difference between these two programming models is similar
                to the difference between paying with cash and paying by cheque.
              </p>
              <p>
                Imagine a world where the only form of payment is cash.
              </p>
              <p>
                I go to the supermarket, pick out the goods I want to buy, go to
                the till, hand over the cash for the goods and leave with the
                goods.
              </p>
              <p>
                This transaction is effectively atomic because I only
                leave with the goods if I have successfully paid for them; if
                the transaction fails I keep my money and leave the goods in the
                store.
              </p>
              <p>
                This transaction is immediately consistent because as soon as I
                pay the cashier for the goods I have less cash in my possession.
              </p>
              <p>
                This transaction is isolated because I can't be in two places at
                once paying two different cashiers.
              </p>
              <p>
                This transaction is durable because the cash and goods are
                physical items representing the state.
              </p>
              <p>
                An in person transaction is also like a local method call in
                that it is very reliable and any problems (e.g. offering the
                wrong amount of cash) are easy to handle and resolve.
              </p>
              <p>
                Now imagine a world where the only form of payment is by cheque
                and you have to wait for the cheque to clear before you can take
                your goods.
              </p>
              <p>
                Obviously, I can't' go into the supermarket and wait 3-5 days at
                the checkout for my check to clear, so the supermarket and I
                have to change we way we interact.
              </p>
              <p>
                So in this scenario, I go into the supermarket and place an
                order for the goods I want, I pay by cheque and tell them when
                to deliver the goods.
              </p>
              <p>
                My transaction is no longer atomic, it is now distributed across
                three separate services. On the day of my delivery, my cheque
                needs to have cleared, the goods need to be in stock and there
                needs to be space in the delivery truck for my order. Any of
                these three things could fail; if they do fail the supermarket
                may have to reallocate space on the truck, return goods to the
                shelves, refund my payment and inform me of the failure.
              </p>
              <p>
                The balance in my bank account is eventually consistent; I may
                have different checks being paid in and paid out with no
                certainty when they will clear.
              </p>
              <p>
                I can check my balance and see how much money I have available
                to spend at that moment, but I've no way of calculating the
                amount of money I actually have; this is because I may not be
                aware of all the uncleared cheques involving my account. This
                may lead me to go overdrawn and may cause checks to bounce.
              </p>
              <p>
                A bank account balance works on the principal of event sourcing;
                instead of storing the current balance of your account it is
                calculated based on the transactions, these transactions are the
                events. This enables the notion of cleared and uncleared
                transactions, which are used to ensure sufficient funds are
                available for transactions to complete. This allows for multiple
                transactions of occur simultaneously without requiring locking
                across all the bank accounts involved in the transaction.
              </p>
              <p>
                Shopping by placing an order could be implemented as a reactive
                system; for example, if your local supermarket was unable to
                fulfill an order, the order could be redirected to a nearby
                supermarket instead.
              </p>
              <p>
                So we have two quite different approaches, cash payments vs.
                cheque payments. Hopefully it's clear that the cash approach is
                the simpler of the two... so why do cheques exist? One reason is
                cash doesn't scale; it's not convenient to store and move large
                quantities of cash.
              </p>
              <p>
                The same concepts that make using cheque payments harder to
                implement, also make microservices harder to implement; however,
                it's worth it for the same reason, microservice projects scale
                better.
              <p>
              <p>
                The take away from this, is microservices are more complex,
                because we're replacing a programming model that was built out
                of reliable and predictable steps, with a model where failures
                and uncertainty are expected at each step, and where <b>you</b>
                have to write code to handle that.
              </p>
            </aside>
          </section>

          <section>
            <h1>Small = less effort</h1>
          </section>

          <section>
            <h2>Small &ne; less effort</h2>

            <ul>
              <li>Distributed transactions</li>
              <li>Eventual consistency</li>
              <li>Event sourcing</li>
              <li>Reactive systems architecture</li>
              <li>More builds to setup &amp; maintain</li>
              <li>Code and data duplication between services</li>
              <li>More external APIs</li>
              <li>More time versioning and releasing artifacts</li>
              <li>More servers to manage and support</li>
            </ul>
          </section>

          <section>
            <h1>It's another evolutionary change</h1>
          </section>

          <section>
            <h2>It's NOT another<br/>evolutionary change</h2>

            <div style="text-align: left;">
            <p>It's not like choosing between Java EE and Spring</p>
            <p>
              It's going to affect everything you do:
              <ul>
                <li>Your organizational structure will need to change</li>
                <li>Various responsibilities will be devolved to microservice teams</li>
                <li>It will change the way you run projects</li>
                <li>Your APIs will be different</li>
                <li>You'll be using different design patterns</li>
                <li>It'll change the way you test, release &amp; support software</li>
              </ul>
            </p>
          </section>
        </section>

        <section class="mixed-dark">
          <h2>API considerations</h2>

          <ul class="increased-spacing">
            <li>Idempotentcy</li>
            <li>UUIDs</li>
            <li>Event sourcing</li>
            <li>Reactive systems architecture</li>
            <li>Distributed transactions</li>
            <li>Eventual consistency</li>
          </ul>

          <aside class="notes">
            <p>
              Let's consider how microservices will affect your APIs.
            </p>
            <ul>
              <li>Idempotentcy: you need to make it safe to retry API calls
                  because there are many more potential points of failure.</li>
              <li>UUIDs: help you to implement idempotentcy; generally required
                  by NoSQL databases.</li>
              <li>Event sourcing: necessary when storing mutable data in
                  eventually consistent databases.</li>
              <li>Reactive systems architecture: helps with performance and
                  reliability</li>
              <li>Distributed transactions: a largely unavoidable side effect of
                  using microservices</li>
              <li>Eventual consistency: used to improve scalability</li>
            </ul>
          </aside>
        </section>

        <section>
          <section data-background-color="#FF7600">
            <h1>Infrastructure requirements</h1>

            <aside class="notes">
              <p>
                More infrastructure requirements than a typical monolithic
                application
              </p>
            </aside>
          </section>

          <section data-background-color="#FF7600">
            <h1>Cloud platform</h1>

            <aside class="notes">
              <p>
                Microservices need a cloud platform.
              </p>
              <p>
                There are simply too many servers to maintain manually.
              </p>
              <p>
                Be careful when choosing a cloud provider, it's generally
                better to go with one of the large established providers,
                than end up being a guinea pig for a new provider.
              </p>
            </aside>
          </section>

          <section data-background-color="#FF7600">
            <h1>Container manager</h1>

            <aside class="notes">
              <ul>
                  <li>Too many containers instances to manage manually</li>
                  <li>e.g. Docker Swarm / Kubernetes</li>
              </ul>
            </aside>
          </section>

          <section data-background-color="#FF7600">
            <h1>Identity and access management (IAM) service</h1>

            <aside class="notes">
              <ul>
                <li>User, passwords and access key management</li>
                <li>Configure who has access to what</li>
              </ul>
            </aside>
          </section>

          <section data-background-color="#FF7600">
            <h1>API gateway service</h1>

            <aside class="notes">
              <ul>
                <li>External entry point to your application</li>
                <li>Permit/deny access based on IAM Service</li>
                <li>Routes external APIs to internal microservices</li>
              </ul>
            </aside>
          </section>

          <section data-background-color="#FF7600">
            <h1>Monitoring and log analytics service</h1>

            <aside class="notes">
              <p>
                With microservices there are simply too many separate log files
                to inspect individually.
              </p>

              This will assist with:
              <ul>
                <li>Implementing auto scaling</li>
                <li>Implementing backpressure</li>
                <li>Implementing alerting</li>
                <li>Resolving partial transactions</li>
                <li>Providing status dashboards</li>
                <li>Providing performance analytics</li>
                <li>Providing a support console</li>
              </ul>
            </aside>
          </section>

          <section data-background-color="#FF7600">
            <h1>Configuration service</h1>

            <aside class="notes">
              <ul>
                <li>Configuration is dynamic</li>
                <li>Nodes added/removed</li>
                <li>Central location to manage/lookup configuration</li>
              </ul>
            </aside>
          </section>

          <section data-background-color="#FF7600">
            <h1>Notification service</h1>

            <aside class="notes">
              <p>
                Reactive systems are asynchronous and message based; going back
                to the shopping by cheque analogy, there is no synchronous
                exchange of cache for goods, there is an order, which is the
                message from the customer, and there are the goods that are
                delivered at a later time, these goods are the message from the
                supermarket.
              </p>
              <p>
                So when microservices are implemented as a reactive system they
                need the equivalent of a delivery truck, to deliver messages to
                the clients those microservices; the notification service is
                that delivery truck.
              </p>
              <p>
                The notification service will typically deliver messages to the
                clients using HTTP push, mobile push or email.
              </p>
            </aside>
          </section>

          <section data-background-color="#FF7600">
            <h1>Deployment pipeline</h1>

            <aside class="notes">
              <ul>
                <li>Synchronized releases &amp; release freezes are not practical</li>
                <li>Small releases would be too frequent to do manually</li>
                <li>Need a mechanism to ensure dependencies are satisfied before deployment</li>
                <li>Need excellent automated test coverage</li>
                <li>Consider feature flags</li>
              </ul>
            </aside>
          </section>
        </section>

        <section class="bad-dark">
          <section>
            <h1>Difficult organizational changes</h1>
          </section>

          <section>
            <h2>Working concurrently</h2>

            <p>
              Where people/teams have to coordinate their work because it is
              affecting others
            </p>

            <aside class="notes">
              <ul>
                <li>
                  The overhead of concurrent development is relatively low
                  within a small team.
                </li>
                <li>
                  The overhead of coordinating work between teams is much
                  higher; it slows down entire teams and causes havoc with
                  planning.
                </li>
              </ul>
            </aside>

          </section>

          <section>
            <h2>Working in parallel</h2>

            <p>Where the work is separate and doesn't require coordination</p>

            <aside class="notes">
              <p>
                With microservices you aim to work in parallel.
              </p>
              <p>
                Where the work is separate and doesn't require coordination.
              </p>
              <p>
                Microservice projects should be run in such a way, that
                concurrent work only occurs within individual microservice
                teams, work between teams and other parties should occur in
                parallel.
              </p>
              <p>
                You should resolve all dependencies on other teams and other
                parties before assigning the microservice to a team for
                implementation.
              </p>
            </aside>
          </section>

          <section>
            <h2>The easiest way to sabotage a microservice project, is to undermine the ability of your teams to work in parallel</h2>
          </section>

          <section>
            <h2>Do not share code between microservices</h2>

            <div style="text-align: left">
              <p>
                Much higher concurrency cost than with a monolithic application:
                <ul class="increased-spacing">
                  <li>Changes are not atomic with multiple repositories</li>
                  <li>Takes multiple teams to schedule and apply changes</li>
                  <li>The more microservices that share the code the more to update</li>
                  <li>Technical debt builds up on services that aren't kept up to date</li>
                  <li>Can impact the release schedule across multiple teams</li>
                  <li>May take a long time to get feedback and iterate improvements</li>
                </ul>
              </p>
            </div>
          </section>

          <section>
            <h2>Do not mandate specific frameworks, libraries, languages and internal implementation patterns</h2>

            <aside class="notes">
              You can still impose requirement on services for logging and monitoring etc.
            </aside>
          </section>

          <section>
            <h2>Do not maintain a central design authority with approval over all design decisions</h2>

            <aside class="notes">
              <p>
                Central design authorities are important on large monolithic
                applications; it's worth spending the extra time to get a
                decision right first time, when a large team may be stuck with a
                decision for many years.
              </p>
              <p>
                With microservices a single team should be responsible for a
                microservice for it's entire lifetime; this includes design,
                implementation, support and maintenance.
              </p>
              <p>
                You don't want an external entity imposing days or weeks of
                delays for decisions that are small in scope and easily changed.
                Instead you want your microservice teams to feel ownership and
                responsibility for their services, and to be able to use an
                agile iterative approach to continually improve.
              </p>
            </aside>
          </section>

          <section>
            <h2>Do not run a microservice project like a large monolithic enterprise application project</h2>

            <aside class="notes">
              <p>
                This is a lot easier to say than to do. Everybody's first
                instinct is to stick with what we know was working before;
                to twist your microservice project into a familiar shape rather
                than adapting to its new shape.
              </p>
              <p>
                You really have to reevaluate all your assumptions and
                procedures.
              </p>
              <p>
                Ask yourself the following questions:
                <ul>
                  <li>
                    Can this responsibility be devolved to the microservice
                    teams?
                  </li>
                  <li>
                    Am I doing everything I can to minimize concurrency between
                    microservice teams?
                  </li>
                  <li>
                    What is the best option, given my goal is to achieve maximum
                    total productivity even at the cost of individual
                    productivity?
                  </li>
                  <li>
                    Given many people on the project lack previous experience
                    with microservices, and it's a rapidly evolving field, how
                    can I encourage research, knowledge sharing and short
                    iterative improvement cycles?
                  </li>
                </ul>
              </p>
            </aside>
          </section>
        </section>

        <section>
          <section data-background-color="#01939A">
            <h1>Running a microservice project</h1>

            <aside class="notes">
            </aside>
          </section>

          <section data-background-color="#01939A">
            <h1>Embrace diversity</h1>

            <aside class="notes">
              <p>You'll likely end up with a mix of teams e.g.:</p>
              <ul>
                <li>multiple Java teams because developers resources are easily available</li>
                <li>a Scala team that work on the most performance critical services</li>
                <li>a Node.js team for services specific to web frontends</li>
                <li>a Go team for simple services where lower resource requirements
                can deliver significant savings on hosting costs</li>
              </ul>
            </aside>
          </section>

          <section data-background-color="#01939A">
            <h1>Communicate ideas and best practice</h1>

            <aside class="notes">
              Encourages a level of consistency between teams without holding anyone up.
            </aside>
          </section>

          <section data-background-color="#01939A">
            <h1>Have an API guild</h1>

            <aside class="notes">
              <p>
                You should have an API guild.
              </p>
              <p>
                This improves API consistency between services.
              </p>
              <p>
                It's important to get your external APIs correct first time; API
                changes will not just mean rework for the team implementing
                the service, but disruption and rework for other teams building
                against the service as well.
              </p>
            </aside>
          </section>

          <section data-background-color="#01939A">
            <h1>Strictly follow TDD/BDD</h1>

            <aside class="notes">
              <p>
                You should strictly follow test driven development or behavior
                driven development.
              </p>
              <p>
                High test coverage with well written tests is essential for
                microservice projects. You'll need both integration tests and
                unit tests to ensure microservices work correctly together.
              </p>
              <p>
                As well as preventing defects from being released, it's
                important to catch defects before they disrupt other
                microservice teams.
              </p>
            </aside>
          </section>

          <section data-background-color="#01939A">
            <h2>Run each team as if they are a separate company</h2>

            <ul class="increased-spacing">
              <li>Make teams responsible for design, implementation and
                  <b>support</b></li>
              <li>Track metrics for each team</li>
              <li>Bill internal users for using microservices</li>
              <li>Empower teams with the agility of a start up</li>
            </ul>
          </section>
        </section>

        <section class="bad-dark">
          <h2>When not to use microservices</h2>

          <ul class="increased-spacing">
            <li>If you're a small start up with tight resources</li>
            <li>If the application is small and unlikely to grow</li>
            <li>If you primarily need ACID behavior</li>
            <li>If you have a lot of cross service transactions</li>
          </ul>
        </section>

        <section data-background-color="#01939A">
          <h2>When to use microservices</h2>

          <ul>
            <li>
              If you need to write a large application quickly
              <ul>
                <li>(as long as you can resource multiple teams)</li>
              </ul>
            </li>
            <li>If you're maintaining a large application for a long time</li>
            <li>If you need fine grained scalability</li>
          </ul>
        </section>

        <section data-background-color="#FF7600" class="mixed-light">
          <h2>In conclusion</h2>

          <ul class="increased-spacing">
            <li>Revolutionary change in approach</li>
            <li>More effort to write but scales better</li>
            <li>Large increase in skill set requirements</li>
            <li>Don't underestimate the task</li>
            <li>Bad idea for most small projects</li>
            <li>Worth considering for most large projects</li>
          </ul>
        </section>
      </div>
    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.js"></script>

    <script>
      // More info https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        history: true,

        // More info https://github.com/hakimel/reveal.js#dependencies
        dependencies: [
          { src: 'plugin/markdown/marked.js' },
          { src: 'plugin/markdown/markdown.js' },
          { src: 'plugin/notes/notes.js', async: true },
          { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
        ]
      });
    </script>
  </body>
</html>
